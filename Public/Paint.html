<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Pixel Grid</title>
    <style>
        #canv {
            position: absolute;
            border: 2px solid whitesmoke;
            
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
            image-rendering: -o-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            -ms-interpolation-mode: nearest-neighbor;

            cursor: url(./assets/img/brush_img.cur) 16 16 auto;
        }

        #grid {
            border: 2px solid whitesmoke;
            
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
            image-rendering: -o-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            -ms-interpolation-mode: nearest-neighbor;
        }

     



    </style>
</head>
<body>
    <input type="color" id="color-input">
    <button id="bucket">BUCKET</button>

    <div id="drawing-space" style="width: 800px; height: 800px;">
        <canvas id="grid" width="800" height="800" style="position: absolute; pointer-events: none;"></canvas>
        
        <canvas id="canv" width="800" height="800" ></canvas>

    </div>
    <input id="size-input" type="range" max="100" value="1" style="width: 800px;">
    <p id="size-text">Size: </p>

    <script>
        const color_input = document.getElementById('color-input')
        const canvas = document.getElementById("canv")
        const grid_canvas = document.getElementById("grid")
        const ctx = canvas.getContext('2d', { willReadFrequently: true })
        const ctx_grid = grid_canvas.getContext('2d')
        const size_input = document.getElementById('size-input')
        const size_text = document.getElementById('size-text') 
        ctx.imageSmoothingEnabled = false;
        const grid_frequency = 16
        const width = canvas.width;
        const height = canvas.height;
        let mouse_down = false;
        let undo_stack = []
        let current_move = {}
        const MAX_UNDO = 10
        changed_pixels = {}
        let tool = 'brush'
        let image_data;
        const bucket_btn = document.getElementById('bucket')
        ctx_grid.strokeStyle = '#ddd'
        ctx_grid.lineWidth = 0.6
        size = 1

        grid_canvas.style.cursor = "url('./assets/img/brush_img.cur') 0 0, auto";

        
        
        bucket_btn.addEventListener('mousedown', () => {
            tool = 'bucket'
        })
        
        function drawBoard(){
            for (let x = 0; x <= width; x+=grid_frequency){
                ctx_grid.beginPath();
                ctx_grid.moveTo(x, 0);
                ctx_grid.lineTo(x, height);
                ctx_grid.stroke();
            }



            for (let y = 0; y <= height; y+=grid_frequency){
                ctx_grid.beginPath();
                ctx_grid.moveTo(0,y)
                ctx_grid.lineTo(width, y)
                ctx_grid.stroke();
            }

        }

    drawBoard();

    function getPixelColor(x,y){
        const data = ctx.getImageData(x * grid_frequency, y * grid_frequency, 1, 1).data
        if (data[3] == 0){
            return 'transparent'
        }
        return `rgb(${data[0]}, ${data[1]}, ${data[2]})`;
    }

    function fixXY(x, y){ // zwraca x i y odpowiadajace gridzie
        const fixed_x = Math.floor(x / grid_frequency)
        const fixed_y = Math.floor(y / grid_frequency)
        return [fixed_x, fixed_y]
    }



    function calculateSurrounding(cx,cy){
        cx = Math.floor(cx);
        cy = Math.floor(cy);
            //tutaj zapytalem chatgpt zeby powiedzial mi jak to moge wykonac, dal mi te rownanie
            //(x - cx)² + (y - cy)² <= r²
            //x i y to punkt ktory sprawdzam, a cx i cy to punkt ktory klikam, jezeli jest mniejsze lub rowne r2 -> nalezy do kola i moge namalowac to
            //sprawdze otoczenie w zasiegu {size} dookola klikniecia i namaluje te ktore sa w okregu



            let points_to_check = []
            let approved_points = []
            if (size % 2 == 0){
                size += 1;
            }

            const radius = (size - 1) / 2;


            for (let xx = -radius; xx <= radius; xx++){
                for (let yy = -radius; yy <= radius; yy++){
                    points_to_check.push([cx + xx, cy + yy])
                } 
            }
            //to tworzy kule balls
            points_to_check.forEach(point => {
                const px = point[0];
                const py = point[1];
                const equation = Math.pow((px - cx), 2) + Math.pow((py - cy), 2)

                if (equation <= Math.pow(radius, 2)){
                    approved_points.push(point)
                    if (!changed_pixels[`${px},${py}`] ){
                        changed_pixels[`${px},${py}`] = {}
                        changed_pixels[`${px},${py}`] = color_input.value
                    }else{
                        changed_pixels[`${px},${py}`] = color_input.value
                    }

                }        
            });
    }


    

    function undo(){
        const latest_undo_data = undo_stack[undo_stack.length - 1]
        for (key in latest_undo_data){
            if (latest_undo_data[key].prev_color != 'transparent'){
                changePixel(key.split(',')[0],key.split(',')[1], latest_undo_data[key].prev_color, false)
            }else{
                erasePixel(key.split(',')[0],key.split(',')[1])
            }
        }

        undo_stack.pop()
    }

    function addNewUndo(){
        undo_stack.push({})
    }

    function modifyLatestUndo(x,y,color,prev_color){
        const latest_undo = undo_stack.length - 1
        let latest_undo_data = undo_stack[latest_undo]
        if (!latest_undo_data[`${x},${y}`]){
            latest_undo_data[`${x},${y}`] = {};
            latest_undo_data[`${x},${y}`]['color'] = color
            latest_undo_data[`${x},${y}`]['prev_color'] = prev_color
        }else{
            latest_undo_data[`${x},${y}`]['color'] = color 
        }
    }

    function addPixelToQueue(x,y,color){
        if (!changed_pixels[`${x},${y}`] ){
            changed_pixels[`${x},${y}`] = {}
             changed_pixels[`${x},${y}`] = color_input.value;
        }else{
            changed_pixels[`${x},${y}`] = color_input.value;
        }
    }

    
    function changePixel(x, y, color = 'black', save_to_undo=true) {//zmienia pixel na canvasie, save_to_undo zapobiega rekursywnemy wykonywaniu przez undo
        ctx.fillStyle = color; 
        if (save_to_undo){
            modifyLatestUndo(x,y,color,getPixelColor(x,y))
        }
        ctx.fillRect(x * grid_frequency, y * grid_frequency, grid_frequency, grid_frequency); 
    }

    
    function erasePixel(x,y){
        ctx.clearRect(x * grid_frequency,y * grid_frequency, grid_frequency, grid_frequency)
        
    }
    function getColotFromImg(imageData, gx, gy) {
        const x = gx * grid_frequency;
        const y = gy * grid_frequency;
        const data = imageData.data;
        const idx = (y * grid_canvas.width + x) * 4;
        if (data[idx + 3] == 0){
            return 'transparent'
        }
        return `rgb(${data[idx]}, ${data[idx + 1]}, ${data[idx + 2]})`;
    }




    let clicked_color;
    function fillBucket(x,y, recurrention = false){
        if (x * grid_frequency < 0 || x * grid_frequency  >= grid_canvas.width || y * grid_frequency < 0 || y * grid_frequency >= grid_canvas.height) return
        const width = Math.floor( grid_canvas.width / grid_frequency)
        const height = Math.floor(grid_canvas.height / grid_frequency)
        const visited = new Array(width * height)
        const queue = [[x,y]]
        image_data = ctx.getImageData(0,0,grid_canvas.width,grid_canvas.height)
        clicked_color = getPixelColor(x,y) 

        while (queue.length > 0) {
            const [cx, cy] = queue.shift();
            const index = cy * width + cx;
            if (cx < 0 || cy < 0 || cx >= width || cy >= height) continue;
            if (visited[index]) continue;
            const current_color = getColotFromImg(image_data, cx, cy)
            visited[index] = 1
            changePixel(cx,cy,color_input.value)
            if (current_color !== clicked_color) continue;
            queue.push([cx + 1, cy]);
            queue.push([cx - 1, cy]);
            queue.push([cx, cy + 1]);
            queue.push([cx, cy - 1]);

        }

    }


    canvas.addEventListener('mousedown', (e) => { 
        if (undo_stack[undo_stack.length - 1] == {}) undo_stack.pop()
        addNewUndo();

        mouse_down = true;
        const fixed_xy = fixXY(e.offsetX, e.offsetY)

        const fixed_x = fixed_xy[0]
        const fixed_y = fixed_xy[1]
        switch (tool) {
            case 'bucket' : {
                fillBucket(fixed_x,fixed_y)
                break
            }
            case 'brush' : {


                calculateSurrounding(fixed_x, fixed_y)
                addPixelToQueue(fixed_x, fixed_y, color_input.value)

                let data = ctx.getImageData(0,0,grid_canvas.width,grid_canvas.height)
            }
        }

    })

    canvas.addEventListener('mouseup', (e) => {
        mouse_down = false;
    })
    let last_x;
    let last_y;


    canvas.addEventListener('mousemove', (e) => {
        if (mouse_down) {

            const fixed_xy = fixXY(e.offsetX, e.offsetY)
            const fixed_x = fixed_xy[0]
            const fixed_y = fixed_xy[1]
            calculateSurrounding(fixed_x, fixed_y)

            if (last_y){    //wygladzanie linii, bez tego troche dziurawe jest
                const dx = fixed_x - last_x;
                const dy = fixed_y - last_y;
                const delta = Math.sqrt(dx * dx + dy * dy); // dlugosc najszybszej drogi (zwyklej prostej) od pozycji z poprzedniego 'ticka' do obecnej

                if (delta > 0.3 * size){ //jezeli zmiana jest wieksza niz 1/3 wielkosci pedzla -> wygladzamy
                    const steps = Math.floor(delta / size/0.3) // dziele te droge na odcinki 1/3 wielkosci pedzla, jest to ilosc dodatkowych punktow miedzy ostatnia i obecna pozycja myszy
                    
                    
                    for (let i = 0; i <= steps; i++){
                        //LERP 
                        //fixed_x - last_x -> przesuniecie myszy
                        // (fixed_x - last_x) * (i/steps) -> i/steps zwraca wartosci od 0 - 1 dzieki czemu dzieli przebyty dystans na czesci    
                        // czyli step 1 z 10 na drodze 100 -> 0.1 * 100 = 10, step 2 -> 20 etc az do konca
                        // to oblicza tylko podzial na kroki, ale trzeba je jeszcze dodac do poprzedniej pozycji, by od niej zaczac wygladzanie
                        // np. z przesuniecia 50 -> 300 zrobi sie 50 -> 100 -> 150 -> 200 -> 250 -> 300
                        const x = last_x + (fixed_x - last_x) * (i / steps)
                        const y = last_y + (fixed_y - last_y) * (i / steps)

                        calculateSurrounding(x, y)
                    }
                }
            }
            last_x = fixed_x
            last_y = fixed_y
            addPixelToQueue(fixed_x,fixed_y,color_input.value)



        }else{
            last_y = undefined
        }
    })

    canvas.addEventListener('mouseleave', e => {
        mouse_down = false;
    })


    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key == 'z'){
            console.log('ctrl z')
            undo();
        }
    })

    setInterval( () => {
        for (let key in changed_pixels){
            const pixel_position = key.split(',')
            changePixel (pixel_position[0], pixel_position[1], changed_pixels[key])
            delete changed_pixels[key]

        }
    }, 25) // pseudo optymalizacja. Daje cos? Nie wiem

    size_input.addEventListener('input', e =>{
        size_text.innerText = `Size: ${e.target.value}`
        size = size = parseInt(e.target.value);
    })
    </script>
</body>
</html>
